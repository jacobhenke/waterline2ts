#!/usr/bin/env node
"use strict";

const program = require("commander"),
  chalk = require("chalk"),
  includeAll = require("include-all"),
  fs = require("fs"),
  args = {};

program
  .version("0.1.0")
  .option("-m, --models <models>", "the directory of models to convert", process.cwd())
  .option("-t, --ts-dir <tsDir>", "The directory to output typescript interfaces", "./ts")
  .option("-f, --force-overwrite", "overwrite existing interfaces")
  .parse(process.argv);

// don't overwrite existing files unless -f
let fileMode = 'wx';
if (program.forceOverwrite) {
  fileMode = 'w';
}

// if the output dir doesn't exist, create it
if (!fs.existsSync(program.tsDir)) {
  fs.mkdirSync(program.tsDir);
}

// get the full path of the output directory, and create a filter that exludes that directory if it exists
let writePrefix = fs.realpathSync(program.tsDir);
let excludeDirs = new RegExp('node_modules|.git|' + writePrefix.split('/').pop());
writePrefix += '/';


console.log(chalk.bold("modelsDir: ") + program.models + "/");
console.log(chalk.bold("    tsDir: ") + writePrefix);

// the module includeAll loads all the files as modules
const models = includeAll({
  dirname: program.models,
  filter: /^([^.]+)\.(js|coffee|litcoffee)$/,
  excludeDirs: excludeDirs,
});

// map lowercase names to PascalCase for associations
const nameMap = [];
for (let name in models) {
  nameMap[name.toLowerCase()] = name;
}

// loop through models
for (let name in models) {
  // generate interfaces
  let interfaceString = `\nexport interface ${name} {`;

  for (let column in models[name].attributes) {
    let colOpts = models[name].attributes[column];
    if (typeof colOpts == 'function') {
      continue; // doesn't seem like there should be functions in attributes, but idk...
    }

    interfaceString += `\n   ${column}`;
    if (!colOpts.required) {
      interfaceString += '?';
    }
    if (colOpts.type) {
      let type = translateType(colOpts.type);
      
      interfaceString += `: ${type};`;
      if (colOpts.type == 'date' || colOpts.type == 'time' || colOpts.type == 'datetime') {
        interfaceString += '  // ' + colOpts.type;
      } else if (colOpts.enum) {
        interfaceString += '  // enum: ' + JSON.stringify(colOpts.enum);
      }

    } else if (colOpts.model) {
      let model = colOpts.model;
      if (nameMap[colOpts.model.toLowerCase()]) {
        model = nameMap[colOpts.model.toLowerCase()];

        // add import to top of file
        interfaceString = `import {${model}} from './${model}';\n` + interfaceString;
      } else {
        console.log('📛  ' + chalk.red("Model " + chalk.bold(model.toLowerCase()) + " was not found"));
        console.dir(nameMap[colOpts.model.toLowerCase()]);
      }
      
      interfaceString += `: ${model};  // Association... See ${model}.ts`;
    }

  }
  // add a "autogenerated by a tool" blurb
  interfaceString = '// Autogenerated via waterline2ts\n\n' + interfaceString;

  interfaceString += '\n}\n';

  // write to file
  fs.open(writePrefix + name + ".ts", fileMode, function(err, fd) {
    if (err) {
      if (err.code === "EEXIST") {
        console.log('❌  ' + chalk.red(chalk.bold(writePrefix + name + ".js") + " already exists..."));
        return;
      }
      return console.log(chalk.red.bold(err));
    }
    fs.write(fd, interfaceString, (err, bytes) => {
      if (err) {
        return console.log(chalk.red.bold(err));
      }
      console.log('✅  ' + chalk.green.bold(name));
    });
  });

  // console.log(interfaceString);

}

function translateType(type) {
  switch (type) {
    case 'integer':
    case 'float':
      return 'number';
    case 'date':
    case 'time':
    case 'datetime':
    case 'binary':
    case 'text':
      return 'string';
    case 'json':
    case 'array':
      return 'Array';
    default:
      return type;
  }
}
